<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Moon Game Settings</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='styles/graph_builder.css') }}">
</head>
<body>
<h1>Game Settings</h1>

<div style="max-width: 600px; margin: auto;">
  <h3>Board Selection</h3>
  <p id="boardFallbackNotice" style="font-style: italic; color: #666;">
    No custom boards uploaded. The default 5x5 board will be used.
  </p>
  
  <div id="boardPreviewContainer" style="margin-top: 10px;"></div>
  
  <!-- Hidden file input and Add tile trigger -->
  <input type="file" id="boardUpload" accept=".json" multiple style="display: none;">
  <div id="addBoardTile" style="
    width: 200px; height: 200px;
    display: inline-flex; align-items: center; justify-content: center;
    border: 2px dashed #ccc;
    color: #777; font-size: 18px;
    cursor: pointer; margin: 10px; border-radius: 6px;">
    ➕ Add Boards
  </div>



  <div id="deck-settings">
    <h3>Deck Settings</h3>
  
    <label>
      <input type="radio" name="deckType" value="infinite" checked>
      Infinite deck
    </label>
    <br>
    <label>
      <input type="radio" name="deckType" value="finite">
      Finite deck
    </label>
  
    <div id="finite-options" style="display:none; margin-top: 10px;">
      <label>
        Copies of each phase:
        <input type="number" id="copiesPerPhase" value="2" min="1">
      </label>
    </div>
  </div>

  <div id="info" style="margin-top: 10px;">
    <p id="boardInfo"></p>
    <p id="deckInfo"></p>
  </div>

  <div id="warnings" style="margin-top: 10px;">
    <p id="warning" style="color: red;"></p>
  </div>

  <div id="startGameWarning" style="margin-top: 10px;">
    <p id="startWarning" style="color: orange; font-weight: bold;"></p>
  </div>



  <button onclick="startGame()">Start Game</button>
</div>

<div id="links" style="text-align:center; margin-top:20px;"></div>

<script>
let roomId = null;

// Parse ?room=moon-abc123 from URL if present
const urlParams = new URLSearchParams(window.location.search);
if (urlParams.has("room")) {
  roomId = urlParams.get("room");
  fetch(`/game_settings_data?room=${roomId}`)
  .then(res => res.json())
  .then(data => {
  })
  .catch(() => console.log("No previous settings found for this room."));
}



function isValidBoard(board) {
  if (!board || typeof board !== "object") return false;
  if (!board.nodes || typeof board.nodes !== "object") return false;

  for (const [name, node] of Object.entries(board.nodes)) {
    if (
      typeof name !== "string" ||
      !node ||
      typeof node !== "object" ||
      !Array.isArray(node.neighbors) ||
      !Array.isArray(node.position) ||
      node.position.length !== 2 ||
      typeof node.position[0] !== "number" ||
      typeof node.position[1] !== "number"
    ) {
      return false;
    }
  }
  return true;
}

let boardPool = [];

document.getElementById("boardUpload").addEventListener("change", function () {
  const files = this.files;
  if (!files.length) return;

  const errors = [];
  let loadedCount = 0;

  for (const file of files) {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const board = JSON.parse(e.target.result);
	board.name = file.name.replace(/\.json$/i, ""); 
        if (isValidBoard(board)) {
          boardPool.push(board);
        } else {
          errors.push(`⚠️ ${file.name} is not a valid board format.`);
        }
      } catch (err) {
        errors.push(`❌ ${file.name} is not valid JSON.`);
      } finally {
        loadedCount++;
        if (loadedCount === files.length) {
	  renderBoardPreviews();
          document.getElementById("warning").innerHTML = errors.join("<br>");
          updateInfo();
          markSettingsChanged();
        }
      }
    };
    reader.readAsText(file);
  }
});



document.getElementById("addBoardTile").addEventListener("click", () => {
  document.getElementById("boardUpload").click();
});




function renderBoardPreviews() {
  const container = document.getElementById("boardPreviewContainer");
  container.innerHTML = ""; // Clear old previews
  const fallbackMsg = document.getElementById("boardFallbackNotice");
  fallbackMsg.style.display = boardPool.length === 0 ? "block" : "none";


  boardPool.forEach((board, index) => {
    // Container for one preview
    const wrapper = document.createElement("div");
    wrapper.className = "board-preview";
    wrapper.style.border = "1px solid #ccc";
    wrapper.style.margin = "10px";
    wrapper.style.padding = "5px";
    wrapper.style.display = "inline-block";
    wrapper.style.textAlign = "center";
    wrapper.style.verticalAlign = "top";
    wrapper.style.background = "#f8f8f8";
    wrapper.style.borderRadius = "6px";
    wrapper.style.width = "220px";

    // Optional board name (if stored under board.name)
    const header = document.createElement("div");
    header.innerText = board.name ? board.name : `Board ${index + 1}`;
    header.style.fontWeight = "bold";
    header.style.marginBottom = "4px";
    wrapper.appendChild(header);

    // Canvas
    const canvas = document.createElement("canvas");
    canvas.width = 200;
    canvas.height = 200;
    canvas.style.cursor = "pointer";
    const ctx = canvas.getContext("2d");
    canvas.addEventListener("click", () => showBoardModal(board));
    wrapper.appendChild(canvas);

    // Footer: info + delete button
    const footer = document.createElement("div");
    footer.style.marginTop = "6px";

    const info = document.createElement("span");
    info.innerText = `${Object.keys(board.nodes).length} nodes`;
    info.style.fontSize = "12px";

    const delBtn = document.createElement("button");
    delBtn.innerText = "Remove";
    delBtn.style.marginLeft = "10px";
    delBtn.onclick = () => {
      boardPool.splice(index, 1);
      renderBoardPreviews();
      updateInfo();
      markSettingsChanged();
    };

    footer.appendChild(info);
    footer.appendChild(delBtn);
    wrapper.appendChild(footer);
    container.appendChild(wrapper);

    // --- Draw board preview on canvas ---
    const positions = Object.values(board.nodes).map(n => n.position);
    const xs = positions.map(p => p[0]);
    const ys = positions.map(p => p[1]);
    const minX = Math.min(...xs), maxX = Math.max(...xs);
    const minY = Math.min(...ys), maxY = Math.max(...ys);

    const padding = 10;
    const scaleX = (canvas.width - 2 * padding) / (maxX - minX || 1);
    const scaleY = (canvas.height - 2 * padding) / (maxY - minY || 1);

    const nodeCoords = {};
    for (const [name, node] of Object.entries(board.nodes)) {
      const [x, y] = node.position;
      const px = padding + (x - minX) * scaleX;
      const py = padding + (y - minY) * scaleY;
      nodeCoords[name] = { x: px, y: py };
    }

    // Edges
    ctx.strokeStyle = "#999";
    ctx.lineWidth = 1;
    for (const [name, node] of Object.entries(board.nodes)) {
      const { x: x1, y: y1 } = nodeCoords[name];
      for (const neighborName of node.neighbors) {
        if (neighborName in nodeCoords) {
          const { x: x2, y: y2 } = nodeCoords[neighborName];
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
      }
    }

    // Squares
    for (const { x, y } of Object.values(nodeCoords)) {
      ctx.fillStyle = "#444";
      ctx.fillRect(x - 5, y - 5, 10, 10);
    }
  });
}








function showBoardModal(board) {
  const modal = document.getElementById("boardModal");
  const canvas = document.getElementById("modalBoardCanvas");
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Find bounding box
  const positions = Object.values(board.nodes).map(n => n.position);
  const xs = positions.map(p => p[0]);
  const ys = positions.map(p => p[1]);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);

  const padding = 20;
  const scaleX = (canvas.width - 2 * padding) / (maxX - minX || 1);
  const scaleY = (canvas.height - 2 * padding) / (maxY - minY || 1);

  // Draw nodes
  for (const node of Object.values(board.nodes)) {
    const [x, y] = node.position;
    const px = padding + (x - minX) * scaleX;
    const py = padding + (y - minY) * scaleY;
    ctx.beginPath();
    ctx.arc(px, py, 6, 0, 2 * Math.PI);
    ctx.fillStyle = "#222";
    ctx.fill();
  }

  modal.style.display = "flex";
}

function closeBoardModal() {
  document.getElementById("boardModal").style.display = "none";
}


function startGame() {
  const urlParams = new URLSearchParams(window.location.search);
  const currentPlayer = urlParams.get("player") || "1";

  const deckType = document.querySelector('input[name="deckType"]:checked').value;
  const copiesPerPhase = deckType === "finite" ? parseInt(document.getElementById("copiesPerPhase").value) : null;

  document.getElementById("startWarning").innerText = "";


  fetch("/start_game", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ 
      boards: boardPool,
      room_id: roomId,
      deckType: deckType,
      copiesPerPhase: copiesPerPhase
    })
  })
  .then(response => response.json())
  .then(data => {
    if (data.room_id) {
      if (roomId) {
        window.location.href = `/game/${roomId}?player=${currentPlayer}`;
      } else {
        document.getElementById("links").innerHTML = `
          ✅ Game created!<br>
          <a href="/game/${data.room_id}?player=1">Player 1 Link</a><br>
          <a href="/game/${data.room_id}?player=2">Player 2 Link</a>
        `;
      }
    } else {
      alert("Failed to create game.");
    }
  })
  .catch(() => alert("Server error starting game."));
}






function markSettingsChanged() {
  document.getElementById("startWarning").innerText = "You changed settings. Press 'Start Game' again to apply changes.";
}




document.addEventListener("DOMContentLoaded", () => {
  const finiteOptions = document.getElementById("finite-options");
  const deckRadios = document.getElementsByName("deckType");

  deckRadios.forEach(radio => {
    radio.addEventListener("change", () => {
      if (document.querySelector('input[name="deckType"]:checked').value === "finite") {
        finiteOptions.style.display = "block";
      } else {
        finiteOptions.style.display = "none";
      }
    });
  });
});

document.querySelectorAll("input[name='deckType'], #copiesPerPhase").forEach(el => {
  el.addEventListener("change", () => {
    updateInfo();
    markSettingsChanged();
  });
});
document.getElementById("copiesPerPhase").addEventListener("input", () => {
  updateInfo();
  markSettingsChanged();
});

document.getElementById("boardUpload").addEventListener("change", () => {
  setTimeout(() => {
    updateInfo();
    markSettingsChanged();
  }, 200);
});



function updateInfo() {
  let nodeCount = 0;
  if (boardPool.length === 0) {
  nodeCount = 25; // default 5x5
} else {
  const largestBoard = Math.max(...boardPool.map(b => Object.keys(b.nodes).length));
  nodeCount = largestBoard;
}

  document.getElementById("boardInfo").innerText = `Number of nodes on board: ${nodeCount}`;

  // Compute deck
  const deckType = document.querySelector('input[name="deckType"]:checked').value;
  let deckText = "";
  let deckSize = Infinity;
  if (deckType === "infinite") {
    deckText = "Deck is infinite.";
  } else {
    const copies = parseInt(document.getElementById("copiesPerPhase").value);
    deckSize = copies * 8; // 8 moon phases
    deckText = `Deck has ${deckSize} cards.`;
  }
  document.getElementById("deckInfo").innerText = deckText;

  // Show warning
  const warningEl = document.getElementById("warning");
  if (deckType === "finite" && boardPool.length > 0) {
    const largestBoard = Math.max(...boardPool.map(b => Object.keys(b.nodes).length));
    if (deckSize < largestBoard) {
      warningEl.innerText = `Warning: Deck has fewer cards than the largest board (${largestBoard} nodes). Game will end when both players run out of cards.`;
    } else {
      warningEl.innerText = "";
    }
  } else {
    warningEl.innerText = "";
  }
}










</script>

<div id="boardModal" style="
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.5);
  justify-content: center;
  align-items: center;
  z-index: 9999;
">
  <div style="position: relative; background: white; padding: 10px; border-radius: 8px;">
    <button onclick="closeBoardModal()" style="
      position: absolute; top: 5px; right: 5px;
      background: #eee; border: none; font-size: 16px;">❌</button>
    <canvas id="modalBoardCanvas" width="500" height="500"></canvas>
  </div>
</div>


</body>
</html>

